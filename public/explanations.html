<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sorting Algorithm Explanations</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <h1>Sorting Algorithm Explanations</h1>
  <section id="bubble">
    <h2>Bubble Sort</h2>
    <p>Bubble Sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order. The pass through the list is repeated until the list is sorted. The algorithm gets its name from the way smaller elements "bubble" to the top of the list.</p>
    <img src="diagrams/bubblesort.jpg" alt="Bubble Sort Diagram">
    <figcaption> Source: https://media.geeksforgeeks.org/wp-content/uploads/20230526103842/1.webp </figcaption>
  </section>
  <section id="insertion">
    <h2>Insertion Sort</h2>
    <p>Insertion Sort is a simple sorting algorithm that builds the final sorted array one item at a time. It is much less efficient on large lists than more advanced algorithms such as quicksort, heapsort, or merge sort. However, insertion sort provides several advantages:</p>
    <ul>
      <li>Simple implementation</li>
      <li>Efficient for (quite) small data sets</li>
      <li>More efficient in practice than most other simple quadratic algorithms such as selection sort or bubble sort</li>
      <li>Adaptive, i.e., efficient for data sets that are already substantially sorted: the time complexity is O(n + d), where d is the number of inversions</li>
      <li>Stable; i.e., does not change the relative order of elements with equal keys</li>
      <li>In-place; i.e., only requires a constant amount O(1) of additional memory space</li>
      <li>Online; i.e., can sort a list as it receives it</li>
    </ul>
  </section>
</section>
<section id="merge">
  <h2>Merge Sort</h2>
  <p>Merge Sort is an efficient, stable, comparison-based, divide and conquer sorting algorithm. Most implementations produce a stable sort, which means that the implementation preserves the input order of equal elements in the sorted output. Merge Sort is a divide and conquer algorithm that was invented by John von Neumann in 1945.</p>
  <section id="selection">
    <h2>Selection Sort</h2>
    <p>Selection Sort is a simple and inefficient sorting algorithm. It works by dividing the input list into two parts: the sublist of items already sorted, which is built up from left to right at the front (left) of the list, and the sublist of items remaining to be sorted that occupy the rest of the list. Initially, the sorted sublist is empty and the unsorted sublist is the entire input list. The algorithm proceeds by finding the smallest (or largest, depending on sorting order) element in the unsorted sublist, exchanging (swapping) it with the leftmost unsorted element (putting it in sorted order), and moving the sublist boundaries one element to the right.</p>
  </section>
  <section id="radix">
    <h2>Radix Sort</h2>
    <p>Radix Sort is a non-comparative sorting algorithm. It avoids comparison by creating and distributing elements into buckets according to their radix. For elements with more than one significant digit, this bucketing process is repeated for each digit, while preserving the ordering of the prior step, until all digits have been considered. For this reason, radix sort has also been called bucket sort and digital sort.</p>
  </section>
  <section id="quick">
    <h2>Quick Sort</h2>
    <p>Quick Sort is an efficient, in-place, comparison-based, divide and conquer sorting algorithm. Developed by Tony Hoare in 1959, it is still a commonly used algorithm for sorting. When implemented well, it can be about two or three times faster than its main competitors, merge sort and heapsort.</p>
  </section>
  <section id="tree">
    <h2>Tree Sort</h2>
    <p>Tree Sort is a sorting algorithm that builds a binary search tree from the elements to be sorted, and then traverses the tree (in-order traversal) so that the elements come out in sorted order. The worst-case time complexity of Tree Sort is O(n^2), but it is O(n log n) on average.</p>
  </section>
  <section id="bogo">
    <h2>Bogo Sort</h2>
    <p>Bogo Sort is a highly ineffective sorting algorithm based on the generate and test paradigm. The algorithm successively generates permutations of its input until it finds one that is sorted. It is not suitable for practical use, but it is used as an educational tool to contrast with more efficient algorithms.</p>
  </section>
  <section id="slow">
    <h2>Slow Sort</h2>
    <p>Slow Sort is a sorting algorithm introduced by Andrei Broder and Jorge Stolfi in 1986. It is of humorous nature and is not intended for practical use. It is a recursive algorithm that combines the principles of insertion sort and merge sort.</p>
  </section>
</body>
</html>